; Exploit assembly payload reversed from arTIfiCE_v2.8xp
; ez80 assembly

        .assume adl=1
        .org    0

Mov9ToOP1       .equ    0020320h        ; _Mov9ToOP1
ChkFindSym      .equ    002050Ch        ; _ChkFindSym
Arc_Unarc       .equ    0021448h        ; unarchive helper

ClrLCDFull      .equ    0020808h        ; _ClrLCDFull
DrawStatusBar   .equ    0021A3Ch        ; _DrawStatusBar
PutS            .equ    00207C0h        ; _PutS
GetKey          .equ    0020D8Ch        ; _GetKey
SetupHome       .equ    0021798h        ; _SetupHome
ForceCmdNoChar  .equ    0021FA8h        ; _os_ForceCmdNoChar

arcInfo         .equ    0D00543h        ; arcInfo struct
curRow          .equ    0D00595h        ; row/col pair

; the exploit uses the following TI-basic code before the assembled payload, this is codenamed GotoASM. See explanation in GotoAsm/explanation.md
;
; 00000000: bb0f ef97 bb16 3131 352b 3011 1170 2aaf  ......115+0..p*.
; 00000010: 2a2b 2aaf 2a11 3ec2 373e 3336 3237 3036  *+*.*.>.7>362706
; 00000020: 3139 3638 3233 3236 3bb0 3937 8239 3936  19682326;.97.996
; 00000030: 3934 3037 3032 3432 3136 393e 7e         94070242169>~
;
; tokenized: inString(toString(binomcdf(115,0))+"?","?"):sin(7:36270619682326ᴇ⁻97*99694070242169:\7e

; on entry hl=start
start:
        adc a, l                        ; first executed instruction, doesn't really do anything useful

        ccf                             ; clear compare flag

        ld      de,041h
        add     hl,de                   ; hl = program_unarchived
        push    hl                      ; store program_unarchived for when Arc_Unarc returns

        or      a,a                     ; clear carry for SBC
        sbc     hl,de                   ; hl = code_base

        ld      de, name9 - start
        add     hl,de                   ; hl = &name9

        call    Mov9ToOP1               ; op1 = 'A'
        call    ChkFindSym              ; find 'A' in VAT

        cp      06h                     ; check whether VAT type < 0x06
        jr      nc, type_ok
        inc     a                       ; if not, coerce
type_ok:
        ld      (hl),a                  ; write coerced type back into the VAT entry

        ld      a,b
        cp      0D0h                    ; page < 0xD0 -> in ram

        pop     hl                      ; restore base
        jr      c, program_unarchived

unarchive_path:
        ld      hl,0E91900h             ; ???
        push    hl
        ld      hl,00008B11h            ; ???
        push    hl
        ld      hl,arcInfo              ; arcInfo pointer
        push    hl
        ld      hl,02A0000h             ; ???
        push    hl
        and     a                       ; clear carry for SBC
        sbc     hl,hl
        add     hl,sp                   ; hl = stack pointer
        push    hl                      ; push Arc_Unarc param struct pointer
        jp      Arc_Unarc               ; Arc_Unarc returns to value on stack

program_unarchived:
        push    hl                      ; save hl = program_unarchived
        call    ClrLCDFull
        call    DrawStatusBar

        ld      hl,0900h                ; position of text
        ld      (curRow),hl

        pop     hl                      ; restore hl = program_unarchived

        ld      de,041h
        and     a                       ; clear carry
        sbc     hl,de                   ; hl = code_base

        ld      de, str - start
        add     hl,de                   ; hl = &str

        call    PutS                    ; draw string etc.
        call    GetKey
        call    SetupHome
        jp      ForceCmdNoChar

name9:
        .db     05h
        .db     'A'
        .db     0,0,0,0,0,0,0

str:
        .db     "arTIfiCE!",0
